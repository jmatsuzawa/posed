README、つーか、メモ

物理的な行指向ではなく、論理的なユニット単位で処理をおこなう po 用のsedである。

* 事前に用語の定義など
- ユニット
ここでは、「ユニット」とはmsgid, msgstrの基本要素とそれに付随するコメント情報をセットとするメッセージの単位である。
たとえば、以下がユニットである。
ユニットの例)
==============================
white-space
#  翻訳者によるコメント (Comment)
#. プログラマーによるコメント (Note)
#: メッセージの出現するソースファイル (Location)
#, フラグ(fuzzyなど) (Flag)
msgid "Source String"
msgstr "Target String"
==============================

- エントリ
ユニットを構成するmsgid、msgstrなどの要素を「エントリ」とここでは呼ぶ。
上記のユニットの例は、
Commentエントリ、
Noteエントリ、
Locationエントリ、
Flagエントリ、
Sourceエントリ(msgid)、
Targetエントリ(msgstr)
で、構成される。


* ツールの説明
物理的な行指向ではなく、論理的なユニット単位で処理をおこなう po 用のsedである。

- 基本的なsedコマンドを実装する
実装するコマンドについては後述。
poでは、ユニットの並び順に意味がないので、sedのマルチライン処理や行の前後関係を意識した機能は実装する予定がない

- アドレス指定が特徴的
sedのアドレス指定とは異なり、エントリ単位でパターン指定をおこなう。
考えかたとしては、Sourceにこのパターンがあって、かつTargetにあのパターンがふくまれるユニットをこう編集する、という感じである。

スクリプトのシンタックスの典型は以下のようになる。
@ENTRY/ADDRESS/!@ENTRY/ADDRESS/!COMMAND

ENTRY:
パターンマッチ対象のエントリーを1文字で指定する。
有効な ENTRY のシンボルは以下のとおり
S: Sourceでマッチ
T: Targetでマッチ
L: Locationでマッチ
F: Flagでマッチ
N: Noteでマッチ
C: Commentでマッチ

ENTRYの指定が無い場合は、Targetが指定されたものとみなす。

ADDRESS:
正規表現のパターン(今のところpythonで使えるものと同等)。
sed では、行番号や範囲でアドレス指定ができるが、このツールでは不要なので実装しない。

COMMAND:

以下のsedコマンドを実装する
(特にd, p, s は最重要なので、サンプルでも実装している)
b
d
p
q
s
t
w
y
:
#

以下は、実装するつもりだが優先度低め
ホールドスペース系。
G
g
H
h
x

以下は、たぶん実装しない。
不要とは言わないがツールとしての用途がまだつかめていない
a
i
r

以下は、実装しないつもり。不要だと考えている。
マルチライン処理系。
(ユースケースがつかめれば実装するかも)
D
N
n
P


ex)
たとえば
$ posed -n -e '/^$/p'
で、未訳メッセージだけを抽出

$ posed -e '/^$/!@F/fuzzy/!d'
だと、未訳(^$)でなく(!)、かつフラグ(@F)がfuzzyになっているメッセージを削除する。それ以外は暗黙出力。
結果的に未訳とfuzzyだけ抽出できる。

ちょっと複雑にすると、
$ posed -e '@C/FIXME/@S/[Cc]ould not/s/できません(?!でした)/できませんでした/'
これだと、Comment(@C)に"FIXME"とあって、かつmsgid(@S, Source)に"[Cc]ould not"とあるメッセージの中の "できません(?!でした)"を"できませんでした"に置換する。
sedに即して分解すると、s/の前までがアドレス指定に相当して、ここでは「Comment(@C)に"FIXME"とあって、かつmsgid(@S, Source)に"[Cc]ould not"とあるメッセージ」を意味する。sコマンドはsedと同様。ただし、編集対象はmsgstrだけとしている。
